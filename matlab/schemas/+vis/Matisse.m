%{
vis.Matisse (manual) # conditions for the matisse stimulus
-> vis.Condition
---
-> vis.BaseNoise128
pre_blank_period            : decimal(5,3)                  # (seconds)
duration                    : decimal(5,3)                  # (seconds)
pattern_width               : smallint                      # pixel size of the resulting pattern
pattern_aspect              : float                         # the aspect ratio of the pattern
pattern_upscale             : tinyint                       # integer upscale factor of the pattern
ori                         : decimal(4,1)                  # degrees. 0=horizontal, then clockwise
outer_ori_delta             : decimal(4,1)                  # degrees. Differerence of outer ori from inner.
ori_coherence               : decimal(4,1)                  # 1=unoriented noise. pi/ori_coherence = bandwidth of orientations.
aperture_x                  : decimal(4,3)                  # x position of the aperture in units of pattern widths: 0=center, 0.5=right edge
aperture_y                  : decimal(4,3)                  # y position of the aperture in units of pattern widths: 0=center, 0.5/pattern_aspect = bottom edge
aperture_r                  : decimal(4,3)                  # aperture radius expressed in units pattern widths
aperture_transition         : decimal(3,3)                  # aperture transition width
annulus_alpha               : decimal(3,2)                  # aperture annulus alpha
inner_contrast              : decimal(4,3)                  # pattern contrast in inner region
outer_contrast              : decimal(4,3)                  # pattern contrast in outer region
second_photodiode=0         : tinyint                       # 1/-1=paint a photodiode white/black patch in the upper right corner
second_photodiode_time=0.0  : decimal(4,1)                  # time delay of the second photodiode relative to the stimulus onset
%}

classdef Matisse < dj.Relvar
    
    methods(Static)
        
        function test()
            cond.noise_seed = 10;
            cond.pattern_width = 80;
            cond.pattern_upscale = 3;
            cond.pattern_aspect = 1.7;
            cond.ori = 0;
            cond.outer_ori_delta = 90;
            cond.ori_coherence = 16;
            cond.aperture_x = 0;
            cond.aperture_y = 0;
            cond.aperture_r = 0.2;
            cond.aperture_transition = 0.05;
            cond.annulus_alpha = 0.0;
            cond.outer_contrast = 0.1;
            cond.inner_contrast = 0.1;            
            tic
            img = vis.Matisse.make(cond);
            toc
            imshow(img+0.5)
            imwrite(img+0.5, '~/Desktop/im2.png')
        end
        
        % DO NOT CHANGE THE FUNCTIONS BELOW  - 2016-11-07
        % They are used for analysis of recordings with the stimulus generated by
        % this code.  If you change this code, you will invalidate the analysis.
        % If you need to modify how the stimulus is generated, create a new
        % stimulus.
        
        function img = make(cond)
            fprintf .
            img = fetch1(vis.BaseNoise128 & struct('noise_seed', cond.noise_seed), ...
                'noise_image');
            img = double(img(...
                1:round(cond.pattern_width/cond.pattern_aspect), ...
                1:cond.pattern_width))/127*1.5;
            outer = upscale(img, cond.pattern_upscale, cond.ori + cond.outer_ori_delta, cond.ori_coherence);
            inner = upscale(img, cond.pattern_upscale, cond.ori, cond.ori_coherence);
            img = aperture(inner*cond.inner_contrast, outer*cond.outer_contrast, ...
                cond.aperture_x, cond.aperture_y, cond.aperture_r, cond.aperture_transition, cond.annulus_alpha);
        end
    end
end


function img = upscale(img, factor, ori, coherence)
% Performs fast resizing of the image by the given integer factor with
% gaussian interpolation.

ori_mix = coherence > 1;  % how much of orientation to mix in

% upscale without interpolation
kernel_sigma = factor;
img = upsample(img', factor, round(factor/2))*factor;
img = upsample(img', factor, round(factor/2))*factor;

% interpolate using gaussian kernel with DC gain = 1
sz = size(img);
[fy,fx] = ndgrid(...
    (-sz(1)/2:sz(1)/2-1)*2*pi/sz(1), ...
    (-sz(2)/2:sz(2)/2-1)*2*pi/sz(2));
fmask = exp(-(fy.^2 + fx.^2)*kernel_sigma.^2/2);

% apply orientation selectivity
theta = mod(atan2(fx,fy) + ori*pi/180 + pi/2, pi) - pi/2;
fmask = ifftshift(fmask.*(1-ori_mix + ori_mix*hann(theta*coherence)));
img = real(ifft2(fmask.*fft2(img)));

% contrast compensation for the effect of orientation selectivity
img = img*(1 + ori_mix*(sqrt(coherence)-1));
end


function y = hann(q)
% circuar hanning mask with symmetric opposite lobes
y = (0.5 + 0.5*cos(q)).*(abs(q)<pi);
end


function img = aperture(inner, outer, x, y, radius, transition, annulus_alpha)
% add aperture and annulus
sz = size(inner);
aspect = sz(1)/sz(2);
[y, x] = ndgrid(linspace(-aspect/2,aspect/2,sz(1))-y, linspace(-.5, .5, sz(2))-x);
r = sqrt(y.*y + x.*x);
mask = 1./(1 + exp(-(r-radius)/(transition/4)));
img = inner.*(1-mask) + outer.*mask;
img = img.*(1 - annulus_alpha*(abs(r-radius)<transition/2));
end


